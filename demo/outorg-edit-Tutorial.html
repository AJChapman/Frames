<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2018-08-07 Tue 13:49 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Frames Tutorial</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Anthony Cowley">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style type="text/css">
 pre.src {background-color: #212121; color: #E0E0E0; overflow: scroll;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #212121; color: #E0E0E0; overflow: scroll;} body { max-width: 600pt; margin: auto} </style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Frames Tutorial</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org220ea81">1. Data Import</a>
<ul>
<li><a href="#org63e8725">1.1. Streaming Cores?</a></li>
<li><a href="#org8c2a1c7">1.2. Sanity Check</a></li>
</ul>
</li>
<li><a href="#org1723a9a">2. Subsetting</a>
<ul>
<li><a href="#org063ab77">2.1. Row Subset</a></li>
<li><a href="#org18829cb">2.2. Column Subset</a></li>
<li><a href="#orgf328b25">2.3. Query / Conditional Subset</a></li>
<li><a href="#org85d55b4">2.4. Column Subset Update</a></li>
<li><a href="#org7f0e064">2.5. Mostly-Uniform Data</a></li>
</ul>
</li>
<li><a href="#org61fc4da">3. Escape Hatch</a></li>
<li><a href="#orgfa57664">4. Better Types</a></li>
<li><a href="#org597000c">5. Appendix</a>
<ul>
<li><a href="#org657f38e">5.1. User Types</a></li>
<li><a href="#org14775bc">5.2. Splice Dump</a></li>
<li><a href="#org826e1f2">5.3. Thanks</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #42A5F5;">{-# LANGUAGE ConstraintKinds, DataKinds, FlexibleContexts, GADTs,</span>
<span style="color: #42A5F5;">             OverloadedStrings, PatternSynonyms, QuasiQuotes,</span>
<span style="color: #42A5F5;">             ScopedTypeVariables, TemplateHaskell, TypeApplications,</span>
<span style="color: #42A5F5;">             TypeOperators, ViewPatterns #-}</span>
</pre>
</div>

<p>
This is a loose port of a
<a href="https://ajkl.github.io/2014/11/23/Dataframes/">dataframe tutorial</a> Rosetta
Stone to compare traditional dataframe tools built in R, Julia,
Python, etc. with
<a href="https://github.com/acowley/Frames">Frames</a>. Performing data
analysis in Haskell brings with it a few advantages:
</p>

<ul class="org-ul">
<li>Interactive exploration is supported in GHCi</li>
<li>GHC produces fast, memory-efficient code when you're ready to run a
program that might take a bit of time</li>
<li>You get to use Haskell to write your own functions when what you
want isn't already defined in the library</li>
<li>The code you write is <i>statically typed</i> so that mismatches between
your code and your data data are found by the type checker</li>
</ul>

<p>
The example <a href="http://grouplens.org/datasets/movielens/">data</a> file
used (specifically, the <code>u.user</code> file from the <i>MovieLens 100k</i>
data set) does not include column headers, nor does it use commas
to separate values, so it does not fall into the sweet spot of CSV
parsing that <code>Frames</code> is aimed at. That said, this mismatch of test
data and library support is a great opportunity to verify that
<code>Frames</code> are flexible enough to meet a variety of needs.
</p>

<p>
We begin with rather a lot of imports to support a variety of test
operations and parser customization. I encourage you to start with a
smaller test program than this!
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #E1BEE7;">import</span> <span style="color: #E1BEE7;">qualified</span> <span style="color: #FFCC80;">Control.Foldl</span> <span style="color: #E1BEE7;">as</span> <span style="color: #FFCC80;">L</span>
<span style="color: #E1BEE7;">import</span> <span style="color: #E1BEE7;">qualified</span> <span style="color: #FFCC80;">Data.Foldable</span> <span style="color: #E1BEE7;">as</span> <span style="color: #FFCC80;">F</span>
<span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">Data.Vinyl</span>
<span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">Data.Vinyl.Functor</span> (<span style="color: #FFCC80;">Identity</span>(<span style="color: #80CBC4;">..</span>), <span style="color: #FFCC80;">Const</span>(<span style="color: #80CBC4;">..</span>))
<span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">Lens.Micro</span>
<span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">Lens.Micro.Extras</span>
<span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">Frames</span>
<span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">Frames.CSV</span> (readTableOpt, rowGen, <span style="color: #FFCC80;">RowGen</span>(<span style="color: #80CBC4;">..</span>))
<span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">Pipes</span> <span style="color: #E1BEE7;">hiding</span> (<span style="color: #FFCC80;">Proxy</span>)
<span style="color: #E1BEE7;">import</span> <span style="color: #E1BEE7;">qualified</span> <span style="color: #FFCC80;">Pipes.Prelude</span> <span style="color: #E1BEE7;">as</span> <span style="color: #FFCC80;">P</span>
</pre>
</div>

<p>
A few other imports will be used for highly customized parsing <a href="#orgfa57664">later</a>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">Frames.CSV</span> (colQ)
<span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">TutorialZipCode</span>
</pre>
</div>

<div id="outline-container-org220ea81" class="outline-2">
<h2 id="org220ea81"><span class="section-number-2">1</span> Data Import</h2>
<div class="outline-text-2" id="text-1">
<p>
We usually package column names with the data to keep things a bit
more self-documenting. In the common case where a data file has a
header row providing column names, and columns are separated by
commas, generating the types needed to import a data set is as simple
as,
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">tableTypes</span> <span style="color: #C5E1A5;">"User"</span> <span style="color: #C5E1A5;">"data/ml-100k/u.user"</span>
</pre>
</div>

<p>
The data set <i>this</i> example considers is rather far from the sweet
spot of CSV processing that <code>Frames</code> is aimed it: it does not include
column headers, nor does it use commas to separate values!  However,
these mismatches do provide an opportunity to see that the <code>Frames</code>
library is flexible enough to meet a variety of needs.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">tableTypes'</span> (rowGen <span style="color: #C5E1A5;">"data/ml-100k/u.user"</span>)
            { rowTypeName <span style="color: #80CBC4;">=</span> <span style="color: #C5E1A5;">"User"</span>
            , columnNames <span style="color: #80CBC4;">=</span> [ <span style="color: #C5E1A5;">"user id"</span>, <span style="color: #C5E1A5;">"age"</span>, <span style="color: #C5E1A5;">"gender"</span>
                            , <span style="color: #C5E1A5;">"occupation"</span>, <span style="color: #C5E1A5;">"zip code"</span> ]
            , separator <span style="color: #80CBC4;">=</span> <span style="color: #C5E1A5;">"|"</span> }
</pre>
</div>

<p>
This template haskell splice explicitly specifies the name for the
inferred record type, column names, a separator string, and the
data file from which to infer the record type (i.e. what type
should be used to represent each column). The result of this splice
is included in an <a href="#org14775bc">appendix</a> below so you can flip
between the generated code and how it is used.
</p>

<p>
Since this data is far from the ideal CSV file, we have to tell
<code>Frames</code> how to interpret the data so that it can decide what data
type to use for each column. Having the types depend upon the data in
the given file is a useful exercise in this domain as the actual shape
of the data is of paramount importance during the early import and
exploration phases of data analysis.
</p>

<p>
We can load the module into <code>cabal repl</code> to see what we have so far.
</p>

<pre class="example">
λ&gt; :i User
type User =
  Record
    '["user id" :-&gt; Int, "age" :-&gt; Int, "gender" :-&gt; Text,
      "occupation" :-&gt; Text, "zip code" :-&gt; Text]
</pre>

<p>
This lets us perform a quick check that the types are basically what
we expect them to be.
</p>

<p>
We now define a streaming representation of the full data set. If the
data set is too large to keep in memory, we can process it as it
streams through RAM.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">movieStream</span> <span style="color: #80CBC4;">::</span> <span style="color: #FFCC80;">MonadSafe</span> m <span style="color: #80CBC4;">=&gt;</span> <span style="color: #FFCC80;">Producer</span> <span style="color: #FFCC80;">User</span> m <span style="color: #FFCC80;">()</span>
<span style="color: #64B5F6;">movieStream</span> <span style="color: #80CBC4;">=</span> readTableOpt userParser <span style="color: #C5E1A5;">"data/ml-100k/u.user"</span>
</pre>
</div>

<p>
Alternately, if we want to run multiple operations against a data set
that <i>can</i> fit in RAM, we can do that. Here we define an in-core (in
memory) array of structures (AoS) representation.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">loadMovies</span> <span style="color: #80CBC4;">::</span> <span style="color: #FFCC80;">IO</span> (<span style="color: #FFCC80;">Frame</span> <span style="color: #FFCC80;">User</span>)
<span style="color: #64B5F6;">loadMovies</span> <span style="color: #80CBC4;">=</span> inCoreAoS movieStream
</pre>
</div>
</div>

<div id="outline-container-org63e8725" class="outline-3">
<h3 id="org63e8725"><span class="section-number-3">1.1</span> Streaming Cores?</h3>
<div class="outline-text-3" id="text-1-1">
<p>
A <code>Frame</code> is an in-memory representation of your data. The <code>Frames</code>
library stores each column as compactly as it knows how, and lets
you index your data as a structure of arrays (where each field of
the structure is an array corresponding to a column of your data),
or as an array of structures, also known as a <code>Frame</code>. These latter
structures correspond to rows of your data. Alternatively, rows of
data may be handled in a streaming fashion so that you are not
limited to available RAM. In the streaming paradigm, you process
each row individually as a single record.
</p>

<p>
A <code>Frame</code> provides <code>O(1)</code> indexing, as well as any other operations
you are familiar with based on the <code>Foldable</code> class. If a data set is
small, keeping it in RAM is usually the fastest way to perform
multiple analyses on that data that you can't fuse into a single
traversal.
</p>

<p>
Alternatively, a <code>Producer</code> of rows is a great way to whittle down a
large data set before moving on to whatever you want to do next.
</p>

<p>
The upshot is that you can work with your data as a collection of
rows with either a densely packed in-memory reporesentation &#x2013; a
<code>Frame</code> &#x2013; or a stream of rows provided by a <code>Producer</code>. The choice
depends on if you want to perform multiple queries against your
data, and, if so, whether you have enough RAM to hold the data. If
the answer to both of those questions is,
<i>"Yes!"</i>, consider using a <code>Frame</code> as in the
<code>loadMovies</code> example. If the answer to either question is,
<i>"Nope!"</i>, you will be better off with a
<code>Producer</code>, as in the <code>movieStream</code> example.
</p>
</div>
</div>

<div id="outline-container-org8c2a1c7" class="outline-3">
<h3 id="org8c2a1c7"><span class="section-number-3">1.2</span> Sanity Check</h3>
<div class="outline-text-3" id="text-1-2">
<p>
We can compute some easy statistics to see how things look.
</p>

<pre class="example">
λ&gt; ms &lt;- loadMovies
λ&gt; L.fold L.minimum (view age &lt;$&gt; ms)
Just 7
</pre>

<p>
When there are multiple properties we would like to compute, we can
fuse multiple traversals into one pass using something like the <a href="http://hackage.haskell.org/package/foldl">foldl</a>
package,
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">minMax</span> <span style="color: #80CBC4;">::</span> <span style="color: #FFCC80;">Ord</span> a <span style="color: #80CBC4;">=&gt;</span> <span style="color: #FFCC80;">L.Fold</span> a (<span style="color: #FFCC80;">Maybe</span> a, <span style="color: #FFCC80;">Maybe</span> a)
<span style="color: #64B5F6;">minMax</span> <span style="color: #80CBC4;">=</span> <span style="color: #FFCC80;">(,)</span> <span style="color: #80CBC4;">&lt;$&gt;</span> L.minimum <span style="color: #80CBC4;">&lt;*&gt;</span> L.maximum
</pre>
</div>

<pre class="example">
λ&gt; L.fold (L.handles age minMax) ms
(Just 7,Just 73)
</pre>

<p>
Here we are projecting the <code>age</code> column out of each record, and
computing the minimum and maximum <code>age</code> across all rows.
</p>
</div>
</div>
</div>

<div id="outline-container-org1723a9a" class="outline-2">
<h2 id="org1723a9a"><span class="section-number-2">2</span> Subsetting</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org063ab77" class="outline-3">
<h3 id="org063ab77"><span class="section-number-3">2.1</span> Row Subset</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Data may be inspected using either Haskell's traditional list API&#x2026;
</p>

<pre class="example">
λ&gt; mapM_ print (take 3 (F.toList ms))
{user id :-&gt; 1, age :-&gt; 24, gender :-&gt; "M", occupation :-&gt; "technician", zip code :-&gt; "85711"}
{user id :-&gt; 2, age :-&gt; 53, gender :-&gt; "F", occupation :-&gt; "other", zip code :-&gt; "94043"}
{user id :-&gt; 3, age :-&gt; 23, gender :-&gt; "M", occupation :-&gt; "writer", zip code :-&gt; "32067"}
</pre>

<p>
&#x2026; or <code>O(1)</code> indexing of individual rows. Here we take the last three
rows of the data set,
</p>

<pre class="example">
λ&gt; mapM_ (print . frameRow ms) [frameLength ms - 3 .. frameLength ms - 1]
{user id :-&gt; 941, age :-&gt; 20, gender :-&gt; "M", occupation :-&gt; "student", zip code :-&gt; "97229"}
{user id :-&gt; 942, age :-&gt; 48, gender :-&gt; "F", occupation :-&gt; "librarian", zip code :-&gt; "78209"}
{user id :-&gt; 943, age :-&gt; 22, gender :-&gt; "M", occupation :-&gt; "student", zip code :-&gt; "77841"}
</pre>

<p>
This lets us view a subset of rows,
</p>

<pre class="example">
λ&gt; mapM_ (print . frameRow ms) [50..55]
{user id :-&gt; 51, age :-&gt; 28, gender :-&gt; "M", occupation :-&gt; "educator", zip code :-&gt; "16509"}
{user id :-&gt; 52, age :-&gt; 18, gender :-&gt; "F", occupation :-&gt; "student", zip code :-&gt; "55105"}
{user id :-&gt; 53, age :-&gt; 26, gender :-&gt; "M", occupation :-&gt; "programmer", zip code :-&gt; "55414"}
{user id :-&gt; 54, age :-&gt; 22, gender :-&gt; "M", occupation :-&gt; "executive", zip code :-&gt; "66315"}
{user id :-&gt; 55, age :-&gt; 37, gender :-&gt; "M", occupation :-&gt; "programmer", zip code :-&gt; "01331"}
{user id :-&gt; 56, age :-&gt; 25, gender :-&gt; "M", occupation :-&gt; "librarian", zip code :-&gt; "46260"}
</pre>
</div>
</div>

<div id="outline-container-org18829cb" class="outline-3">
<h3 id="org18829cb"><span class="section-number-3">2.2</span> Column Subset</h3>
<div class="outline-text-3" id="text-2-2">
<p>
We can consider a single column.
</p>

<pre class="example">
λ&gt; take 6 . F.toList $ view occupation &lt;$&gt; ms
["technician","other","writer","technician","other","executive"]
</pre>

<p>
Or multiple columns,
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">miniUser</span> <span style="color: #80CBC4;">::</span> <span style="color: #FFCC80;">User</span> <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Record</span> '[<span style="color: #FFCC80;">Occupation</span>, <span style="color: #FFCC80;">Gender</span>, <span style="color: #FFCC80;">Age</span>]
<span style="color: #64B5F6;">miniUser</span> <span style="color: #80CBC4;">=</span> rcast
</pre>
</div>

<pre class="example">
λ&gt; mapM_ print . take 6 . F.toList $ fmap miniUser ms
{occupation :-&gt; "technician", gender :-&gt; "M", age :-&gt; 24}
{occupation :-&gt; "other", gender :-&gt; "F", age :-&gt; 53}
{occupation :-&gt; "writer", gender :-&gt; "M", age :-&gt; 23}
{occupation :-&gt; "technician", gender :-&gt; "M", age :-&gt; 24}
{occupation :-&gt; "other", gender :-&gt; "F", age :-&gt; 33}
{occupation :-&gt; "executive", gender :-&gt; "M", age :-&gt; 42}
</pre>

<p>
If you'd rather not define a function like <code>miniUser</code>, you can fix
the types in-line by using the <code>rcast</code> function.
</p>

<pre class="example">
λ&gt; :set -XTypeApplications -XDataKinds
λ&gt; rcast @'[Occupation,Gender,Age] $ frameRow ms 0
{occupation :-&gt; "technician", gender :-&gt; "M", age :-&gt; 24}
</pre>
</div>
</div>

<div id="outline-container-orgf328b25" class="outline-3">
<h3 id="orgf328b25"><span class="section-number-3">2.3</span> Query / Conditional Subset</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Filtering our frame is rather nicely done using the
<a href="http://hackage.haskell.org/package/pipes">pipes</a> package. Here
we pick out the users whose occupation is "writer".
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">writers</span> <span style="color: #80CBC4;">::</span> (<span style="color: #FFCC80;">Occupation</span> <span style="color: #80CBC4;">&#8712;</span> rs, <span style="color: #FFCC80;">Monad</span> m) <span style="color: #80CBC4;">=&gt;</span> <span style="color: #FFCC80;">Pipe</span> (<span style="color: #FFCC80;">Record</span> rs) (<span style="color: #FFCC80;">Record</span> rs) m r
<span style="color: #64B5F6;">writers</span> <span style="color: #80CBC4;">=</span> P.filter ((<span style="color: #80CBC4;">==</span> <span style="color: #C5E1A5;">"writer"</span>) <span style="color: #80CBC4;">.</span> view occupation)
</pre>
</div>

<pre class="example">
λ&gt; runSafeEffect $ movieStream &gt;-&gt; writers &gt;-&gt; P.take 6 &gt;-&gt; P.print
{user id :-&gt; 3, age :-&gt; 23, gender :-&gt; "M", occupation :-&gt; "writer", zip code :-&gt; "32067"}
{user id :-&gt; 21, age :-&gt; 26, gender :-&gt; "M", occupation :-&gt; "writer", zip code :-&gt; "30068"}
{user id :-&gt; 22, age :-&gt; 25, gender :-&gt; "M", occupation :-&gt; "writer", zip code :-&gt; "40206"}
{user id :-&gt; 28, age :-&gt; 32, gender :-&gt; "M", occupation :-&gt; "writer", zip code :-&gt; "55369"}
{user id :-&gt; 50, age :-&gt; 21, gender :-&gt; "M", occupation :-&gt; "writer", zip code :-&gt; "52245"}
{user id :-&gt; 122, age :-&gt; 32, gender :-&gt; "F", occupation :-&gt; "writer", zip code :-&gt; "22206"}
</pre>

<p>
If you're not too keen on all the <code>pipes</code> syntax in that example, you
could also write it using a helper function provided by <code>Frames</code>,
</p>

<pre class="example">
λ&gt; pipePreview movieStream 6 writers
</pre>

<p>
This is a handy way to try out various maps and filters you may want
to eventually apply to a large data set.
</p>
</div>
</div>

<div id="outline-container-org85d55b4" class="outline-3">
<h3 id="org85d55b4"><span class="section-number-3">2.4</span> Column Subset Update</h3>
<div class="outline-text-3" id="text-2-4">
<p>
We can also apply a function to a subset of columns of each row! Here,
we want to apply a function with type <code>Int -&gt; Int</code> to two columns
whose values are of type <code>Int</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">intFieldDoubler</span> <span style="color: #80CBC4;">::</span> <span style="color: #FFCC80;">Record</span> '[<span style="color: #FFCC80;">UserId</span>, <span style="color: #FFCC80;">Age</span>] <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Record</span> '[<span style="color: #FFCC80;">UserId</span>, <span style="color: #FFCC80;">Age</span>]
<span style="color: #64B5F6;">intFieldDoubler</span> <span style="color: #80CBC4;">=</span> mapMono (<span style="color: #80CBC4;">*</span> 2)
</pre>
</div>

<p>
Let's preview the effect of this function by applying it to the
<code>UserId</code> and <code>Age</code> columns of the first three rows of our data set.
</p>

<pre class="example">
λ&gt; pipePreview movieStream 3 (P.map (rsubset %~ intFieldDoubler))
{user id :-&gt; 2, age :-&gt; 48, gender :-&gt; "M", occupation :-&gt; "technician", zip code :-&gt; "85711"}
{user id :-&gt; 4, age :-&gt; 106, gender :-&gt; "F", occupation :-&gt; "other", zip code :-&gt; "94043"}
{user id :-&gt; 6, age :-&gt; 46, gender :-&gt; "M", occupation :-&gt; "writer", zip code :-&gt; "32067"}
</pre>

<p>
This is a neat way of manipulating a few columns without having to
worry about what other columns might exist. You might want to use this
for normalizing the capitalization, or truncating the length of,
various text fields, for example.
</p>
</div>
</div>

<div id="outline-container-org7f0e064" class="outline-3">
<h3 id="org7f0e064"><span class="section-number-3">2.5</span> Mostly-Uniform Data</h3>
<div class="outline-text-3" id="text-2-5">
<p>
<i>(Warning: This section veers into types that are likely of more
use to library authors than end users.)</i>
</p>

<p>
Suppose we don't know much about our data, but we do know that it
starts with an identifying column, and then some number of numeric
columns. We can structurally peel off the first column, perform a
constrained polymorphic operation on the other columns, then glue
the first column back on to the result.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">addTwoRest</span> <span style="color: #80CBC4;">::</span> <span style="color: #FFCC80;">RecMapMethod</span> <span style="color: #FFCC80;">Num</span> <span style="color: #FFCC80;">ElField</span> rs
           <span style="color: #80CBC4;">=&gt;</span> <span style="color: #FFCC80;">Record</span> (s <span style="color: #FFCC80;">:-&gt;</span> a '<span style="color: #FFCC80;">:</span> rs) <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Record</span> (s <span style="color: #FFCC80;">:-&gt;</span> a '<span style="color: #FFCC80;">:</span> rs)
<span style="color: #64B5F6;">addTwoRest</span> (h <span style="color: #FFCC80;">:&amp;</span> t) <span style="color: #80CBC4;">=</span> h <span style="color: #FFCC80;">:&amp;</span> aux t
  <span style="color: #E1BEE7;">where</span> aux <span style="color: #80CBC4;">=</span> mapFields <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">Num</span> (<span style="color: #80CBC4;">\</span>x <span style="color: #80CBC4;">-&gt;</span> x <span style="color: #80CBC4;">+</span> 2)
</pre>
</div>

<pre class="example">
λ&gt; addTwoRest (rcast @'[Occupation, UserId, Age] (frameRow ms 0))
{occupation :-&gt; "technician", user id :-&gt; 3, age :-&gt; 26}
</pre>

<p>
But what if we don't want to rely entirely on ordering of our rows?
Here, we know there is an identifying column, <code>Occupation</code>, and we
want to shuffle it around to the head of the record while mapping a
constrained polymorphic operation over the other columns.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">addTwoOccupation</span> <span style="color: #80CBC4;">::</span> (<span style="color: #FFCC80;">CanDelete</span> <span style="color: #FFCC80;">Occupation</span> rs,
                     rs' <span style="color: #80CBC4;">~</span> <span style="color: #FFCC80;">RDelete</span> <span style="color: #FFCC80;">Occupation</span> rs,
                     <span style="color: #FFCC80;">RecMapMethod</span> <span style="color: #FFCC80;">Num</span> <span style="color: #FFCC80;">ElField</span> rs')
                 <span style="color: #80CBC4;">=&gt;</span> <span style="color: #FFCC80;">Record</span> rs <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Record</span> (<span style="color: #FFCC80;">Occupation</span> '<span style="color: #FFCC80;">:</span> <span style="color: #FFCC80;">RDelete</span> <span style="color: #FFCC80;">Occupation</span> rs)
<span style="color: #64B5F6;">addTwoOccupation</span> r <span style="color: #80CBC4;">=</span>
  rget <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">Occupation</span> r <span style="color: #FFCC80;">:&amp;</span> mapFields <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">Num</span> (<span style="color: #80CBC4;">+</span> 2) (rdel <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">Occupation</span> r)
</pre>
</div>

<pre class="example">
λ&gt; addTwoOccupation (rcast @'[UserId,Age,Occupation] (frameRow ms 0))
{occupation :-&gt; "technician", user id :-&gt; 3, age :-&gt; 26}
</pre>

<p>
It is a bit clumsy to delete and then add back a particular field,
and the dependence on explicit structure is relying a bit more on
coincidence than we might like. We could choose, instead, to work
with row types that contain a distinguished column somewhere in
their midst, but regarding precisely <i>where</i> it is, or <i>how many</i>
other fields there are, we care not.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">addTwoOccupation'</span> <span style="color: #80CBC4;">::</span> <span style="color: #E1BEE7;">forall</span> rs rs'<span style="color: #80CBC4;">.</span>
                     (<span style="color: #FFCC80;">CanDelete</span> <span style="color: #FFCC80;">Occupation</span> rs,
                      rs' <span style="color: #80CBC4;">~</span> <span style="color: #FFCC80;">RDelete</span> <span style="color: #FFCC80;">Occupation</span> rs,
                      <span style="color: #FFCC80;">RecMapMethod</span> <span style="color: #FFCC80;">Num</span> <span style="color: #FFCC80;">ElField</span> rs')
                  <span style="color: #80CBC4;">=&gt;</span> <span style="color: #FFCC80;">Record</span> rs <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Record</span> rs
<span style="color: #64B5F6;">addTwoOccupation'</span> <span style="color: #80CBC4;">=</span> rsubset <span style="color: #80CBC4;">%~</span> mapFields <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">Num</span> <span style="color: #80CBC4;">@</span>rs' (<span style="color: #80CBC4;">+</span> 2)
</pre>
</div>

<pre class="example">
λ&gt; addTwoOccupation' (rcast @'[UserId,Age,Occupation] (frameRow ms 0))
{user id :-&gt; 3, age :-&gt; 26, occupation :-&gt; "technician"}
</pre>

<p>
We can unpack this type a bit to understand what is happening. A
<code>Frames</code> <code>Record</code> is a record from the <code>Vinyl</code> library, except that
each type has phantom column information. This metadata is
available to the type checker, but is erased during compilation so
that it does not impose any runtime overhead. What we are doing
here is saying that we will operate on a <code>Frames</code> row type, <code>Record
rs</code>, that has an element <code>Occupation</code>, and that deleting this
element works properly (i.e. the leftover fields are a proper
subset of the original row type). We further state &#x2013; with the
<code>AsVinyl</code> constraint &#x2013; that we want to work on the unadorned field
values, temporarily discarding their header information, with the
<code>mapMethod</code> function that will treat our richly-typed row as a less
informative <code>Vinyl</code> record.
</p>

<p>
We then peer through a lens onto the set of all unadorned fields other
than <code>Occupation</code>, apply a function with a <code>Num</code> constraint to each of
those fields, then pull back out of the lens reattaching the column
header information on our way. All of that manipulation and
bookkeeping is managed by the type checker.
</p>

<p>
Lest we forget we are working in a typed setting, what happens if
the constraint on our polymorphic operation can't be satisfied by
one of the columns?
</p>

<pre class="example">
λ&gt; addTwoOccupation (rcast @'[Age,Occupation,Gender] (frameRow ms 0))

&lt;interactive&gt;:15:1-16:
    No instance for (Num Text) arising from a use of ‘addTwoOccupation’
    In the expression:
      addTwoOccupation
        (rcast @'[Age, Occupation, Gender] (frameRow ms 0))
    In an equation for ‘it’:
        it
          = addTwoOccupation
              (rcast @'[Age, Occupation, Gender] (frameRow ms 0))
</pre>

<p>
This error message isn't ideal in that it doesn't tell us which
column failed to satisfy the constraint. Hopefully this can be
improved in the future!
</p>
</div>
</div>
</div>

<div id="outline-container-org61fc4da" class="outline-2">
<h2 id="org61fc4da"><span class="section-number-2">3</span> Escape Hatch</h2>
<div class="outline-text-2" id="text-3">
<p>
When you're done with <code>Frames</code> and want to get back to more
familiar monomorphic pastures, you can bundle your data up.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">restInts</span> <span style="color: #80CBC4;">::</span> (<span style="color: #FFCC80;">RecordToList</span> (<span style="color: #FFCC80;">Unlabeled</span> rs), <span style="color: #FFCC80;">StripFieldNames</span> rs,
             <span style="color: #FFCC80;">RecMapMethod</span> ((<span style="color: #80CBC4;">~</span>) <span style="color: #FFCC80;">Int</span>) <span style="color: #FFCC80;">Identity</span> (<span style="color: #FFCC80;">Unlabeled</span> rs))
         <span style="color: #80CBC4;">=&gt;</span> <span style="color: #FFCC80;">Record</span> (s <span style="color: #FFCC80;">:-&gt;</span> <span style="color: #FFCC80;">Text</span> '<span style="color: #FFCC80;">:</span> rs) <span style="color: #80CBC4;">-&gt;</span> (<span style="color: #FFCC80;">Text</span>, [<span style="color: #FFCC80;">Int</span>])
<span style="color: #64B5F6;">restInts</span> (recUncons <span style="color: #80CBC4;">-&gt;</span> (h,t)) <span style="color: #80CBC4;">=</span> (h, recordToList t')
  <span style="color: #E1BEE7;">where</span> t' <span style="color: #80CBC4;">=</span> rmapMethod <span style="color: #80CBC4;">@</span>((<span style="color: #80CBC4;">~</span>) <span style="color: #FFCC80;">Int</span>) (<span style="color: #FFCC80;">Const</span> <span style="color: #80CBC4;">.</span> getIdentity) (stripNames t)
</pre>
</div>

<pre class="example">
λ&gt; restInts (rcast @'[Occupation,UserId,Age] (frameRow ms 0))
("technician",[1,24])
</pre>
</div>
</div>

<div id="outline-container-orgfa57664" class="outline-2">
<h2 id="orgfa57664"><span class="section-number-2">4</span> Better Types</h2>
<div class="outline-text-2" id="text-4">
<p>
A common disappointment of parsing general data sets is the
reliance on text for data representation even <i>after</i> parsing. If
you find that the default <code>Columns</code> spectrum of potential column
types that <code>Frames</code> uses doesn't capture desired structure, you can
go ahead and define your own universe of column types! The <code>User</code>
row types we've been playing with here is rather boring: it only
uses <code>Int</code> and <code>Text</code> column types. But <code>Text</code> is far too vague a
type for a column like <code>zipCode</code>.
</p>

<p>
All of the zip codes in this set are five characters, and most are
standard numeric US zip codes. Let's go ahead and define our own
universe of column types.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #E1BEE7;">data</span> <span style="color: #FFCC80;">ZipT</span> <span style="color: #80CBC4;">=</span> <span style="color: #FFCC80;">ZipUS</span> <span style="color: #FFCC80;">Int</span> <span style="color: #FFCC80;">Int</span> <span style="color: #FFCC80;">Int</span> <span style="color: #FFCC80;">Int</span> <span style="color: #FFCC80;">Int</span>
          <span style="color: #80CBC4;">|</span> <span style="color: #FFCC80;">ZipWorld</span> <span style="color: #FFCC80;">Char</span> <span style="color: #FFCC80;">Char</span> <span style="color: #FFCC80;">Char</span> <span style="color: #FFCC80;">Char</span> <span style="color: #FFCC80;">Char</span>
  <span style="color: #E1BEE7;">deriving</span> (<span style="color: #FFCC80;">Eq</span>, <span style="color: #FFCC80;">Ord</span>, <span style="color: #FFCC80;">Show</span>, <span style="color: #FFCC80;">Typeable</span>)

<span style="color: #E1BEE7;">type</span> <span style="color: #E1BEE7;">instance</span> <span style="color: #FFCC80;">VectorFor</span> <span style="color: #FFCC80;">ZipT</span> <span style="color: #80CBC4;">=</span> <span style="color: #FFCC80;">V.Vector</span>

<span style="color: #E1BEE7;">instance</span> <span style="color: #FFCC80;">Readable</span> <span style="color: #FFCC80;">ZipT</span>  <span style="color: #E1BEE7;">where</span>
  fromText t
      <span style="color: #80CBC4;">|</span> T.length t <span style="color: #80CBC4;">==</span> 5 <span style="color: #80CBC4;">=</span> <span style="color: #E1BEE7;">let</span> cs<span style="color: #80CBC4;">@</span>[v,w,x,y,z] <span style="color: #80CBC4;">=</span> T.unpack t
                              [a,b,c,d,e] <span style="color: #80CBC4;">=</span> map C.digitToInt cs
                          <span style="color: #E1BEE7;">in</span> <span style="color: #E1BEE7;">if</span> all C.isDigit cs
                             <span style="color: #E1BEE7;">then</span> return <span style="color: #80CBC4;">$</span> <span style="color: #FFCC80;">ZipUS</span> a b c d e
                             <span style="color: #E1BEE7;">else</span> return <span style="color: #80CBC4;">$</span> <span style="color: #FFCC80;">ZipWorld</span> v w x y z
      <span style="color: #80CBC4;">|</span> otherwise <span style="color: #80CBC4;">=</span> mzero

<span style="color: #E1BEE7;">type</span> <span style="color: #FFCC80;">MyColumns</span> <span style="color: #80CBC4;">=</span> <span style="color: #FFCC80;">ZipT</span> '<span style="color: #FFCC80;">:</span> <span style="color: #FFCC80;">CommonColumns</span>
</pre>
</div>

<p>
Note that these definitions must be imported from a separate module
to satisfy GHC's stage restrictions related to Template
Haskell. The full code for the custom type may be found in an <a href="#org657f38e">appendix</a>.
</p>

<p>
We name this record type <code>U2</code>, and give all the generated column types
and lenses a prefix, "u2", so they don't conflict with the definitions
we generated earlier.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">tableTypes'</span> (rowGen <span style="color: #C5E1A5;">"data/ml-100k/u.user"</span>)
            { rowTypeName <span style="color: #80CBC4;">=</span> <span style="color: #C5E1A5;">"U2"</span>
            , columnNames <span style="color: #80CBC4;">=</span> [ <span style="color: #C5E1A5;">"user id"</span>, <span style="color: #C5E1A5;">"age"</span>, <span style="color: #C5E1A5;">"gender"</span>
                            , <span style="color: #C5E1A5;">"occupation"</span>, <span style="color: #C5E1A5;">"zip code"</span> ]
            , separator <span style="color: #80CBC4;">=</span> <span style="color: #C5E1A5;">"|"</span>
            , tablePrefix <span style="color: #80CBC4;">=</span> <span style="color: #C5E1A5;">"u2"</span>
            , columnUniverse <span style="color: #80CBC4;">=</span> <span style="color: #80CBC4;">$</span>(colQ ''<span style="color: #FFCC80;">MyColumns</span>) }


<span style="color: #64B5F6;">movieStream2</span> <span style="color: #80CBC4;">::</span> <span style="color: #FFCC80;">MonadSafe</span> m <span style="color: #80CBC4;">=&gt;</span> <span style="color: #FFCC80;">Producer</span> <span style="color: #FFCC80;">U2</span> m <span style="color: #FFCC80;">()</span>
<span style="color: #64B5F6;">movieStream2</span> <span style="color: #80CBC4;">=</span> readTableOpt u2Parser <span style="color: #C5E1A5;">"data/ml-100k/u.user"</span>
</pre>
</div>

<p>
This new record type, <code>U2</code>, has a more interesting <code>zip code</code>
column.
</p>

<pre class="example">
λ&gt; :i U2
type U2 =
  Record
    '["user id" :-&gt; Int, "age" :-&gt; Int, "gender" :-&gt; Text,
      "occupation" :-&gt; Text, "zip code" :-&gt; ZipT]
</pre>

<p>
Let's take the occupations of the first 10 users from New England,
New Jersey, and other places whose zip codes begin with a zero.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #64B5F6;">neOccupations</span> <span style="color: #80CBC4;">::</span> (<span style="color: #FFCC80;">U2ZipCode</span> <span style="color: #80CBC4;">&#8712;</span> rs, <span style="color: #FFCC80;">U2Occupation</span> <span style="color: #80CBC4;">&#8712;</span> rs, <span style="color: #FFCC80;">Monad</span> m)
              <span style="color: #80CBC4;">=&gt;</span> <span style="color: #FFCC80;">Pipe</span> (<span style="color: #FFCC80;">Record</span> rs) <span style="color: #FFCC80;">Text</span> m r
<span style="color: #64B5F6;">neOccupations</span> <span style="color: #80CBC4;">=</span> P.filter (isNewEngland <span style="color: #80CBC4;">.</span> view u2ZipCode)
                <span style="color: #80CBC4;">&gt;-&gt;</span> P.map (view u2Occupation)
  <span style="color: #E1BEE7;">where</span> isNewEngland (<span style="color: #FFCC80;">ZipUS</span> 0 <span style="color: #E1BEE7;">_</span> <span style="color: #E1BEE7;">_</span> <span style="color: #E1BEE7;">_</span> <span style="color: #E1BEE7;">_</span>) <span style="color: #80CBC4;">=</span> <span style="color: #FFCC80;">True</span>
        isNewEngland <span style="color: #E1BEE7;">_</span> <span style="color: #80CBC4;">=</span> <span style="color: #FFCC80;">False</span>
</pre>
</div>

<pre class="example">
λ&gt; runSafeEffect $ movieStream2 &gt;-&gt; neOccupations &gt;-&gt; P.take 10 &gt;-&gt; P.print
"administrator"
"student"
"other"
"programmer"
"librarian"
"entertainment"
"marketing"
"programmer"
"educator"
"healthcare"
</pre>

<p>
So there we go! We've done both row and column subset queries with a
strongly typed query (namely, <code>isNewEngland</code>). Another situation in
which one might want to define a custom universe of column types is
when dealing with dates. This would let you both reject rows with
badly formatted dates, for example, and efficiently query the data set
with richly-typed queries.
</p>

<p>
Even better, did you notice the types of <code>writers</code> and
<code>neOccupations</code>? They are polymorphic over the full row type!
That's what the <code>(Occupation ∈ rs)</code> constraint signifies: such a
function will work for record types with any set of fields, <code>rs</code>, so
long as <code>Occupation</code> is an element of that set. This means that if
your schema changes, or you switch to a related but different data
set, <b>these functions can still be used without even touching the
code</b>. Just recompile against the new data set, and you're good to go.
</p>
</div>
</div>

<div id="outline-container-org597000c" class="outline-2">
<h2 id="org597000c"><span class="section-number-2">5</span> Appendix</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org657f38e" class="outline-3">
<h3 id="org657f38e"><span class="section-number-3">5.1</span> User Types</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Here are the definitions needed to define the <code>MyColumns</code> type with
its more descriptive <code>ZipT</code> type. We have to define these things in
a separate module from our main work due to GHC's stage
restrictions regarding Template Haskell. Specifically, <code>ZipT</code> and
its instances are used at compile time to infer the record type
needed to represent the data file. Notice the extension point here
is not too rough: you prepend new, more refined, type compatibility
checks to the head of <code>CommonColumns</code>, or you can build up your own
list of expected types.
</p>

<p>
This may not be something you'd want to do for every data
set. However, the <i>ability</i> to refine the structure of parsed data
is in keeping with the overall goal of <code>Frames</code>: it's easy to take
off, and the sky's the limit.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #42A5F5;">{-# LANGUAGE DataKinds, DeriveDataTypeable, TypeFamilies, TypeOperators #-}</span>
<span style="color: #E1BEE7;">module</span> <span style="color: #FFCC80;">TutorialZipCode</span> <span style="color: #E1BEE7;">where</span>
<span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">Control.Monad</span> (mzero)
<span style="color: #E1BEE7;">import</span> <span style="color: #E1BEE7;">qualified</span> <span style="color: #FFCC80;">Data.Char</span> <span style="color: #E1BEE7;">as</span> <span style="color: #FFCC80;">C</span>
<span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">Data.Readable</span> (<span style="color: #FFCC80;">Readable</span>(fromText))
<span style="color: #E1BEE7;">import</span> <span style="color: #E1BEE7;">qualified</span> <span style="color: #FFCC80;">Data.Text</span> <span style="color: #E1BEE7;">as</span> <span style="color: #FFCC80;">T</span>
<span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">Data.Typeable</span>
<span style="color: #E1BEE7;">import</span> <span style="color: #E1BEE7;">qualified</span> <span style="color: #FFCC80;">Data.Vector</span> <span style="color: #E1BEE7;">as</span> <span style="color: #FFCC80;">V</span>
<span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">Frames.InCore</span> (<span style="color: #FFCC80;">VectorFor</span>)
<span style="color: #E1BEE7;">import</span> <span style="color: #FFCC80;">Frames</span>

<span style="color: #E1BEE7;">data</span> <span style="color: #FFCC80;">ZipT</span> <span style="color: #80CBC4;">=</span> <span style="color: #FFCC80;">ZipUS</span> <span style="color: #FFCC80;">Int</span> <span style="color: #FFCC80;">Int</span> <span style="color: #FFCC80;">Int</span> <span style="color: #FFCC80;">Int</span> <span style="color: #FFCC80;">Int</span>
          <span style="color: #80CBC4;">|</span> <span style="color: #FFCC80;">ZipWorld</span> <span style="color: #FFCC80;">Char</span> <span style="color: #FFCC80;">Char</span> <span style="color: #FFCC80;">Char</span> <span style="color: #FFCC80;">Char</span> <span style="color: #FFCC80;">Char</span>
  <span style="color: #E1BEE7;">deriving</span> (<span style="color: #FFCC80;">Eq</span>, <span style="color: #FFCC80;">Ord</span>, <span style="color: #FFCC80;">Show</span>, <span style="color: #FFCC80;">Typeable</span>)

<span style="color: #E1BEE7;">type</span> <span style="color: #E1BEE7;">instance</span> <span style="color: #FFCC80;">VectorFor</span> <span style="color: #FFCC80;">ZipT</span> <span style="color: #80CBC4;">=</span> <span style="color: #FFCC80;">V.Vector</span>

<span style="color: #E1BEE7;">instance</span> <span style="color: #FFCC80;">Readable</span> <span style="color: #FFCC80;">ZipT</span>  <span style="color: #E1BEE7;">where</span>
  fromText t
      <span style="color: #80CBC4;">|</span> T.length t <span style="color: #80CBC4;">==</span> 5 <span style="color: #80CBC4;">=</span> <span style="color: #E1BEE7;">let</span> cs<span style="color: #80CBC4;">@</span>[v,w,x,y,z] <span style="color: #80CBC4;">=</span> T.unpack t
                              [a,b,c,d,e] <span style="color: #80CBC4;">=</span> map C.digitToInt cs
                          <span style="color: #E1BEE7;">in</span> <span style="color: #E1BEE7;">if</span> all C.isDigit cs
                             <span style="color: #E1BEE7;">then</span> return <span style="color: #80CBC4;">$</span> <span style="color: #FFCC80;">ZipUS</span> a b c d e
                             <span style="color: #E1BEE7;">else</span> return <span style="color: #80CBC4;">$</span> <span style="color: #FFCC80;">ZipWorld</span> v w x y z
      <span style="color: #80CBC4;">|</span> otherwise <span style="color: #80CBC4;">=</span> mzero

<span style="color: #E1BEE7;">type</span> <span style="color: #FFCC80;">MyColumns</span> <span style="color: #80CBC4;">=</span> <span style="color: #FFCC80;">ZipT</span> '<span style="color: #FFCC80;">:</span> <span style="color: #FFCC80;">CommonColumns</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org14775bc" class="outline-3">
<h3 id="org14775bc"><span class="section-number-3">5.2</span> Splice Dump</h3>
<div class="outline-text-3" id="text-5-2">
<p>
The Template Haskell splices we use produce quite a lot of
code. The raw dumps of these splices can be hard to read, but I
have included some elisp code for cleaning up that output in the
design notes for <code>Frames</code>. Here is what we get from the
<code>tableTypes'</code> splice shown above.
</p>

<p>
The overall structure is this:
</p>

<ul class="org-ul">
<li>A <code>Record</code> type called <code>User</code> with all necessary columns</li>
<li>A <code>userParser</code> value that overrides parsing defaults</li>
<li>A type synonym for each column that pairs the column name with its
type</li>
<li>A lens to work with each column on any given row</li>
</ul>

<p>
Remember that for CSV files that include a header, the splice you
write in your code need not include the column names or separator
character.
</p>

<div class="org-src-container">
<pre class="src src-haskell">  tableTypes'
    (rowGen <span style="color: #C5E1A5;">"data/ml-100k/u.user"</span>)
    {rowTypeName <span style="color: #80CBC4;">=</span> <span style="color: #C5E1A5;">"User"</span>,
     columnNames <span style="color: #80CBC4;">=</span> [<span style="color: #C5E1A5;">"user id"</span>, <span style="color: #C5E1A5;">"age"</span>, <span style="color: #C5E1A5;">"gender"</span>, <span style="color: #C5E1A5;">"occupation"</span>,
                    <span style="color: #C5E1A5;">"zip code"</span>],
     separator <span style="color: #80CBC4;">=</span> <span style="color: #C5E1A5;">"|"</span>})
<span style="color: #80CBC4;">======&gt;</span>
<span style="color: #E1BEE7;">type</span> <span style="color: #FFCC80;">User</span> <span style="color: #80CBC4;">=</span> <span style="color: #FFCC80;">Record</span> [<span style="color: #C5E1A5;">"user id"</span> <span style="color: #FFCC80;">:-&gt;</span> <span style="color: #FFCC80;">Int</span>, <span style="color: #C5E1A5;">"age"</span> <span style="color: #FFCC80;">:-&gt;</span> <span style="color: #FFCC80;">Int</span>, <span style="color: #C5E1A5;">"gender"</span> <span style="color: #FFCC80;">:-&gt;</span> <span style="color: #FFCC80;">Text</span>, <span style="color: #C5E1A5;">"occupation"</span> <span style="color: #FFCC80;">:-&gt;</span> <span style="color: #FFCC80;">Text</span>, <span style="color: #C5E1A5;">"zip code"</span> <span style="color: #FFCC80;">:-&gt;</span> <span style="color: #FFCC80;">Text</span>]

<span style="color: #64B5F6;">userParser</span> <span style="color: #80CBC4;">::</span> <span style="color: #FFCC80;">ParserOptions</span>
<span style="color: #64B5F6;">userParser</span> <span style="color: #80CBC4;">=</span> <span style="color: #FFCC80;">ParserOptions</span> (<span style="color: #FFCC80;">Just</span> (map T.pack [<span style="color: #C5E1A5;">"user id"</span>
                                             , <span style="color: #C5E1A5;">"age"</span>
                                             , <span style="color: #C5E1A5;">"gender"</span>
                                             , <span style="color: #C5E1A5;">"occupation"</span>
                                             , <span style="color: #C5E1A5;">"zip code"</span>]))
                           (T.pack <span style="color: #C5E1A5;">"|"</span>)
                           (<span style="color: #FFCC80;">Frames.CSV.RFC4180Quoting</span> <span style="color: #C5E1A5;">'"'</span>)

<span style="color: #E1BEE7;">type</span> <span style="color: #FFCC80;">UserId</span> <span style="color: #80CBC4;">=</span> <span style="color: #C5E1A5;">"user id"</span> <span style="color: #FFCC80;">:-&gt;</span> <span style="color: #FFCC80;">Int</span>
<span style="color: #64B5F6;">userId</span> <span style="color: #80CBC4;">::</span> <span style="color: #E1BEE7;">forall</span> f_0 rs_1 <span style="color: #80CBC4;">.</span>
          (<span style="color: #FFCC80;">Functor</span> f_0, <span style="color: #FFCC80;">RElem</span> <span style="color: #FFCC80;">UserId</span> rs_1 (<span style="color: #FFCC80;">RIndex</span> <span style="color: #FFCC80;">UserId</span> rs_1))
       <span style="color: #80CBC4;">=&gt;</span> (<span style="color: #FFCC80;">Int</span> <span style="color: #80CBC4;">-&gt;</span> f_0 <span style="color: #FFCC80;">Int</span>)
       <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Record</span> rs_1
       <span style="color: #80CBC4;">-&gt;</span> f_0 (<span style="color: #FFCC80;">Record</span> rs_1)
<span style="color: #64B5F6;">userId</span> <span style="color: #80CBC4;">=</span> rlens <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">UserId</span> <span style="color: #80CBC4;">.</span> rfield
<span style="color: #64B5F6;">userId'</span> <span style="color: #80CBC4;">::</span> <span style="color: #E1BEE7;">forall</span> f_2 g_3 rs_4 <span style="color: #80CBC4;">.</span>
           (<span style="color: #FFCC80;">Functor</span> f_2, <span style="color: #FFCC80;">RElem</span> <span style="color: #FFCC80;">UserId</span> rs_4 (<span style="color: #FFCC80;">RIndex</span> <span style="color: #FFCC80;">UserId</span> rs_4))
        <span style="color: #80CBC4;">=&gt;</span> (g_3 <span style="color: #FFCC80;">UserId</span> <span style="color: #80CBC4;">-&gt;</span> f_2 (g_3 <span style="color: #FFCC80;">UserId</span>))
        <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Rec</span> g_3 rs_4
        <span style="color: #80CBC4;">-&gt;</span> f_2 (<span style="color: #FFCC80;">Rec</span> g_3 rs_4)
<span style="color: #64B5F6;">userId'</span> <span style="color: #80CBC4;">=</span> rlens' <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">UserId</span>

<span style="color: #E1BEE7;">type</span> <span style="color: #FFCC80;">Age</span> <span style="color: #80CBC4;">=</span> <span style="color: #C5E1A5;">"age"</span> <span style="color: #FFCC80;">:-&gt;</span> <span style="color: #FFCC80;">Int</span>
<span style="color: #64B5F6;">age</span> <span style="color: #80CBC4;">::</span> <span style="color: #E1BEE7;">forall</span> f_5 rs_6 <span style="color: #80CBC4;">.</span>
       (<span style="color: #FFCC80;">Functor</span> f_5, <span style="color: #FFCC80;">RElem</span> <span style="color: #FFCC80;">Age</span> rs_6 (<span style="color: #FFCC80;">RIndex</span> <span style="color: #FFCC80;">Age</span> rs_6))
    <span style="color: #80CBC4;">=&gt;</span> (<span style="color: #FFCC80;">Int</span> <span style="color: #80CBC4;">-&gt;</span> f_5 <span style="color: #FFCC80;">Int</span>)
    <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Record</span> rs_6
    <span style="color: #80CBC4;">-&gt;</span> f_5 (<span style="color: #FFCC80;">Record</span> rs_6)
<span style="color: #64B5F6;">age</span> <span style="color: #80CBC4;">=</span> rlens <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">Age</span> <span style="color: #80CBC4;">.</span> rfield
<span style="color: #64B5F6;">age'</span> <span style="color: #80CBC4;">::</span> <span style="color: #E1BEE7;">forall</span> f_7 g_8 rs_9 <span style="color: #80CBC4;">.</span>
        (<span style="color: #FFCC80;">Functor</span> f_7, <span style="color: #FFCC80;">RElem</span> <span style="color: #FFCC80;">Age</span> rs_9 (<span style="color: #FFCC80;">RIndex</span> <span style="color: #FFCC80;">Age</span> rs_9))
     <span style="color: #80CBC4;">=&gt;</span> (g_8 <span style="color: #FFCC80;">Age</span> <span style="color: #80CBC4;">-&gt;</span> f_7 (g_8 <span style="color: #FFCC80;">Age</span>))
     <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Rec</span> g_8 rs_9
     <span style="color: #80CBC4;">-&gt;</span> f_7 (<span style="color: #FFCC80;">Rec</span> g_8 rs_9)
<span style="color: #64B5F6;">age'</span> <span style="color: #80CBC4;">=</span> rlens' <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">Age</span>

<span style="color: #E1BEE7;">type</span> <span style="color: #FFCC80;">Gender</span> <span style="color: #80CBC4;">=</span> <span style="color: #C5E1A5;">"gender"</span> <span style="color: #FFCC80;">:-&gt;</span> <span style="color: #FFCC80;">Text</span>
<span style="color: #64B5F6;">gender</span> <span style="color: #80CBC4;">::</span> <span style="color: #E1BEE7;">forall</span> f_10 rs_11 <span style="color: #80CBC4;">.</span>
          (<span style="color: #FFCC80;">Functor</span> f_10, <span style="color: #FFCC80;">RElem</span> <span style="color: #FFCC80;">Gender</span> rs_11 (<span style="color: #FFCC80;">RIndex</span> <span style="color: #FFCC80;">Gender</span> rs_11))
       <span style="color: #80CBC4;">=&gt;</span> (<span style="color: #FFCC80;">Text</span> <span style="color: #80CBC4;">-&gt;</span> f_10 <span style="color: #FFCC80;">Text</span>)
       <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Record</span> rs_11
       <span style="color: #80CBC4;">-&gt;</span> f_10 (<span style="color: #FFCC80;">Record</span> rs_11)
<span style="color: #64B5F6;">gender</span> <span style="color: #80CBC4;">=</span> rlens <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">Gender</span> <span style="color: #80CBC4;">.</span> rfield
<span style="color: #64B5F6;">gender'</span> <span style="color: #80CBC4;">::</span> <span style="color: #E1BEE7;">forall</span> f_12 g_13 rs_14 <span style="color: #80CBC4;">.</span>
           (<span style="color: #FFCC80;">Functor</span> f_12, <span style="color: #FFCC80;">RElem</span> <span style="color: #FFCC80;">Gender</span> rs_14 (<span style="color: #FFCC80;">RIndex</span> <span style="color: #FFCC80;">Gender</span> rs_14))
        <span style="color: #80CBC4;">=&gt;</span> (g_13 <span style="color: #FFCC80;">Gender</span> <span style="color: #80CBC4;">-&gt;</span> f_12 (g_13 <span style="color: #FFCC80;">Gender</span>))
        <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Rec</span> g_13 rs_14
        <span style="color: #80CBC4;">-&gt;</span> f_12 (<span style="color: #FFCC80;">Rec</span> g_13 rs_14)
<span style="color: #64B5F6;">gender'</span> <span style="color: #80CBC4;">=</span> rlens' <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">Gender</span>

<span style="color: #E1BEE7;">type</span> <span style="color: #FFCC80;">Occupation</span> <span style="color: #80CBC4;">=</span> (<span style="color: #FFCC80;">:-&gt;</span>) <span style="color: #C5E1A5;">"occupation"</span>
                                   <span style="color: #FFCC80;">Text</span>
<span style="color: #64B5F6;">occupation</span> <span style="color: #80CBC4;">::</span> <span style="color: #E1BEE7;">forall</span> f_15 rs_16 <span style="color: #80CBC4;">.</span>
              (<span style="color: #FFCC80;">Functor</span> f_15, <span style="color: #FFCC80;">RElem</span> <span style="color: #FFCC80;">Occupation</span> rs_16 (<span style="color: #FFCC80;">RIndex</span> <span style="color: #FFCC80;">Occupation</span> rs_16))
           <span style="color: #80CBC4;">=&gt;</span> (<span style="color: #FFCC80;">Text</span> <span style="color: #80CBC4;">-&gt;</span> f_15 <span style="color: #FFCC80;">Text</span>)
           <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Record</span> rs_16
           <span style="color: #80CBC4;">-&gt;</span> f_15 (<span style="color: #FFCC80;">Record</span> rs_16)
<span style="color: #64B5F6;">occupation</span> <span style="color: #80CBC4;">=</span> rlens <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">Occupation</span> <span style="color: #80CBC4;">.</span> rfield
<span style="color: #64B5F6;">occupation'</span> <span style="color: #80CBC4;">::</span> <span style="color: #E1BEE7;">forall</span> f_17 g_18 rs_19 <span style="color: #80CBC4;">.</span>
               (<span style="color: #FFCC80;">Functor</span> f_17, <span style="color: #FFCC80;">RElem</span> <span style="color: #FFCC80;">Occupation</span> rs_19 (<span style="color: #FFCC80;">RIndex</span> <span style="color: #FFCC80;">Occupation</span> rs_19))
            <span style="color: #80CBC4;">=&gt;</span> (g_18 <span style="color: #FFCC80;">Occupation</span> <span style="color: #80CBC4;">-&gt;</span> f_17 (g_18 <span style="color: #FFCC80;">Occupation</span>))
            <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Rec</span> g_18 rs_19
            <span style="color: #80CBC4;">-&gt;</span> f_17 (<span style="color: #FFCC80;">Rec</span> g_18 rs_19)
<span style="color: #64B5F6;">occupation'</span> <span style="color: #80CBC4;">=</span> rlens' <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">Occupation</span>

<span style="color: #E1BEE7;">type</span> <span style="color: #FFCC80;">ZipCode</span> <span style="color: #80CBC4;">=</span> <span style="color: #C5E1A5;">"zip code"</span> <span style="color: #FFCC80;">:-&gt;</span> <span style="color: #FFCC80;">Text</span>
<span style="color: #64B5F6;">zipCode</span> <span style="color: #80CBC4;">::</span> <span style="color: #E1BEE7;">forall</span> f_20 rs_21 <span style="color: #80CBC4;">.</span>
           (<span style="color: #FFCC80;">Functor</span> f_20, <span style="color: #FFCC80;">RElem</span> <span style="color: #FFCC80;">ZipCode</span> rs_21 (<span style="color: #FFCC80;">RIndex</span> <span style="color: #FFCC80;">ZipCode</span> rs_21))
        <span style="color: #80CBC4;">=&gt;</span> (<span style="color: #FFCC80;">Text</span> <span style="color: #80CBC4;">-&gt;</span> f_20 <span style="color: #FFCC80;">Text</span>)
        <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Record</span> rs_21
        <span style="color: #80CBC4;">-&gt;</span> f_20 (<span style="color: #FFCC80;">Record</span> rs_21)
<span style="color: #64B5F6;">zipCode</span> <span style="color: #80CBC4;">=</span> rlens <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">ZipCode</span> <span style="color: #80CBC4;">.</span> rfield
<span style="color: #64B5F6;">zipCode'</span> <span style="color: #80CBC4;">::</span> <span style="color: #E1BEE7;">forall</span> f_22 g_23 rs_24 <span style="color: #80CBC4;">.</span>
            (<span style="color: #FFCC80;">Functor</span> f_22, <span style="color: #FFCC80;">RElem</span> <span style="color: #FFCC80;">ZipCode</span> rs_24 (<span style="color: #FFCC80;">RIndex</span> <span style="color: #FFCC80;">ZipCode</span> rs_24))
         <span style="color: #80CBC4;">=&gt;</span> (g_23 <span style="color: #FFCC80;">ZipCode</span> <span style="color: #80CBC4;">-&gt;</span> f_22 (g_23 <span style="color: #FFCC80;">ZipCode</span>))
         <span style="color: #80CBC4;">-&gt;</span> <span style="color: #FFCC80;">Rec</span> g_23 rs_24
         <span style="color: #80CBC4;">-&gt;</span> f_22 (<span style="color: #FFCC80;">Rec</span> g_23 rs_24)
<span style="color: #64B5F6;">zipCode'</span> <span style="color: #80CBC4;">=</span> rlens' <span style="color: #80CBC4;">@</span><span style="color: #FFCC80;">ZipCode</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org826e1f2" class="outline-3">
<h3 id="org826e1f2"><span class="section-number-3">5.3</span> Thanks</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Thanks to Greg Hale and Ben Gamari for reviewing early drafts of this document.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
