<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Frames Tutorial</title>
<!-- 2015-01-20 Tue 19:27 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Anthony Cowley" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<style type="text/css">
 pre.src {background-color: #272822; color: #F8F8F2;} body { max-width: 600pt; margin: auto} </style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Frames Tutorial</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Data Import</a>
<ul>
<li><a href="#sec-1-1">1.1. Streaming Cores?</a></li>
<li><a href="#sec-1-2">1.2. Sanity Check</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Subsetting</a>
<ul>
<li><a href="#sec-2-1">2.1. Row Subset</a></li>
<li><a href="#sec-2-2">2.2. Column Subset</a></li>
<li><a href="#sec-2-3">2.3. Query / Conditional Subset</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Better Types</a></li>
<li><a href="#sec-4">4. Appendix</a>
<ul>
<li><a href="#sec-4-1">4.1. User Types</a></li>
<li><a href="#sec-4-2">4.2. Splice Dump</a></li>
<li><a href="#sec-4-3">4.3. Thanks</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #75715E; font-style: italic;">{-# LANGUAGE DataKinds, FlexibleContexts, OverloadedStrings,</span>
<span style="color: #75715E; font-style: italic;">             TemplateHaskell, TypeOperators #-}</span>
</pre>
</div>

<p>
This is a loose port of a
<a href="http://ajkl.github.io/Dataframes/">dataframe tutorial</a> Rosetta
Stone to compare traditional dataframe tools built in R, Julia,
Python, etc. with <code>Frames</code>.
</p>

<p>
The example data file used does not include column headers, nor
does it use commas to separate values, so it does not fall into the
sweet spot of CSV parsing that <code>Frames</code> is aimed at. That said,
this mismatch of test data and library support is a great
opportunity to verify that <code>Frames</code> are flexible enough to meet a
variety of needs.
</p>

<p>
We begin with rather a lot of imports to support a variety of test
operations and parser customization. I encourage you to start with a
smaller test program than this!
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #F92672;">import</span> <span style="color: #66D9EF;">Control.Applicative</span>
<span style="color: #F92672;">import</span> <span style="color: #F92672;">qualified</span> <span style="color: #66D9EF;">Control.Foldl</span> <span style="color: #F92672;">as</span> <span style="color: #66D9EF;">L</span>
<span style="color: #F92672;">import</span> <span style="color: #F92672;">qualified</span> <span style="color: #66D9EF;">Data.Foldable</span> <span style="color: #F92672;">as</span> <span style="color: #66D9EF;">F</span>
<span style="color: #F92672;">import</span> <span style="color: #66D9EF;">Lens.Family</span>
<span style="color: #F92672;">import</span> <span style="color: #66D9EF;">Frames</span>
<span style="color: #F92672;">import</span> <span style="color: #66D9EF;">Frames.CSV</span> (readTableOpt)
<span style="color: #F92672;">import</span> <span style="color: #66D9EF;">Pipes</span> <span style="color: #F92672;">hiding</span> (<span style="color: #66D9EF;">Proxy</span>)
<span style="color: #F92672;">import</span> <span style="color: #F92672;">qualified</span> <span style="color: #66D9EF;">Pipes.Prelude</span> <span style="color: #F92672;">as</span> <span style="color: #66D9EF;">P</span>
</pre>
</div>

<p>
A few other imports will be used for highly customized parsing <a href="#sec-3">later</a>.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #F92672;">import</span> <span style="color: #66D9EF;">Frames.CSV</span> (rowGen, <span style="color: #66D9EF;">RowGen</span>(<span style="color: #FD971F;">..</span>), colQ)
<span style="color: #F92672;">import</span> <span style="color: #66D9EF;">TutorialUsers</span>
</pre>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Data Import</h2>
<div class="outline-text-2" id="text-1">
<p>
We usually package column names with the data to keep things a bit
more self-documenting. In the common case where a data file has a
header row providing column names, and columns are separated by
commas, generating the types needed to import a data set is as simple
as,
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #A6E22E;">tableTypes</span> <span style="color: #E6DB74;">"Users"</span> <span style="color: #E6DB74;">"data/ml-100k/u.user"</span>
</pre>
</div>

<p>
The data set <i>this</i> example considers is rather far from the sweet
spot of CSV processing that <code>Frames</code> is aimed it: it does not include
column headers, nor does it use commas to separate values!  However,
these mismatches do provide an opportunity to see that the <code>Frames</code>
library is flexible enough to meet a variety of needs.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #A6E22E;">tableTypes'</span>  rowGen { rowTypeName <span style="color: #FD971F;">=</span> <span style="color: #E6DB74;">"Users"</span>
                    , columnNames <span style="color: #FD971F;">=</span> [ <span style="color: #E6DB74;">"user id"</span>, <span style="color: #E6DB74;">"age"</span>, <span style="color: #E6DB74;">"gender"</span>
                                    , <span style="color: #E6DB74;">"occupation"</span>, <span style="color: #E6DB74;">"zip code"</span> ]
                    , separator <span style="color: #FD971F;">=</span> <span style="color: #E6DB74;">"|"</span> }
             <span style="color: #E6DB74;">"data/ml-100k/u.user"</span>
</pre>
</div>

<p>
This template haskell splice explicitly specifies the name for the
inferred record type, column names, a separator string, and the
data file from which to infer the record type (i.e. what type
should be used to represent each column). The result of this splice
is included in an <a href="#sec-4-2">appendix</a> below so you can flip
between the generated code and how it is used.
</p>

<p>
We can load the module into <code>cabal repl</code> to see what we have so far.
</p>

<pre class="example">
λ&gt; :i Users
type Users =
  Rec
    '["user id" :-&gt; Int, "age" :-&gt; Int, "gender" :-&gt; Text,
      "occupation" :-&gt; Text, "zip code" :-&gt; Text]
</pre>

<p>
This lets us perform a quick check that the types are basically what
we expect them to be.
</p>

<p>
We now define a streaming representation of the full data set. If the
data set is too large to keep in memory, we can process it as it
streams through RAM.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #A6E22E;">movieStream</span> <span style="color: #FD971F;">::</span> <span style="color: #66D9EF;">Producer</span> <span style="color: #66D9EF;">Users</span> <span style="color: #66D9EF;">IO</span> <span style="color: #66D9EF;">()</span>
<span style="color: #A6E22E;">movieStream</span> <span style="color: #FD971F;">=</span> readTableOpt usersParser <span style="color: #E6DB74;">"data/ml-100k/u.user"</span>
</pre>
</div>

<p>
Alternately, if we want to run multiple operations against a data set
that <i>can</i> fit in RAM, we can do that. Here we define an in-core (in
memory) array of structures (AoS) representation.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #A6E22E;">loadMovies</span> <span style="color: #FD971F;">::</span> <span style="color: #66D9EF;">IO</span> (<span style="color: #66D9EF;">Frame</span> <span style="color: #66D9EF;">Users</span>)
<span style="color: #A6E22E;">loadMovies</span> <span style="color: #FD971F;">=</span> inCoreAoS movieStream
</pre>
</div>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Streaming Cores?</h3>
<div class="outline-text-3" id="text-1-1">
<p>
A <code>Frame</code> is an in-memory representation of your data. The <code>Frames</code>
library stores each column as compactly as it knows how, and lets you
index your data as a structure of arrays (where each field of the
structure is an array corresponding to a column of your data), or as
an array of structures, also known as a <code>Frame</code>. These latter
structures correspond to rows of your data, and rows of data may be
handled in a streaming fashion so that you are not limited to
available RAM. In the streaming paradigm, you process each row
individually as a single record.
</p>

<p>
A <code>Frame</code> provides <code>O(1)</code> indexing, as well as any other operations
you are familiar with based on the <code>Foldable</code> class. If a data set is
small, keeping it in RAM is usually the fastest way to perform
multiple analyses on that data that you can't fuse into a single
traversal.
</p>

<p>
Alternatively, a <code>Producer</code> of rows is a great way to whittle down a
large data set before moving on to whatever you want to do next.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Sanity Check</h3>
<div class="outline-text-3" id="text-1-2">
<p>
We can compute some easy statistics to see how things look.
</p>

<pre class="example">
λ&gt; ms &lt;- loadMovies
λ&gt; L.fold L.minimum (view age &lt;$&gt; ms)
Just 7
</pre>

<p>
When there are multiple properties we would like to compute, we can
fuse multiple traversals into one pass using something like the <a href="http://hackage.haskell.org/package/foldl">foldl</a>
package
</p>

<pre class="example">
λ&gt; L.fold (L.pretraverse age ((,) &lt;$&gt; L.minimum &lt;*&gt; L.maximum)) ms
(Just 7,Just 73)
</pre>

<p>
Here we are projecting the <code>age</code> column out of each record, and
computing the minimum and maximum <code>age</code> for all rows.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Subsetting</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Row Subset</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Data may be inspected using either Haskell's traditional list API&#x2026;
</p>

<pre class="example">
λ&gt; mapM_ print (take 3 (F.toList ms))
{user id :-&gt; 1, age :-&gt; 24, gender :-&gt; "M", occupation :-&gt; "technician", zip code :-&gt; "85711"}
{user id :-&gt; 2, age :-&gt; 53, gender :-&gt; "F", occupation :-&gt; "other", zip code :-&gt; "94043"}
{user id :-&gt; 3, age :-&gt; 23, gender :-&gt; "M", occupation :-&gt; "writer", zip code :-&gt; "32067"}
</pre>

<p>
&#x2026; or <code>O(1)</code> indexing of individual rows. Here we take the last three
rows of the data set,
</p>

<pre class="example">
λ&gt; mapM_ (print . frameRow ms) [frameLength ms - 3 .. frameLength ms - 1]
{user id :-&gt; 941, age :-&gt; 20, gender :-&gt; "M", occupation :-&gt; "student", zip code :-&gt; "97229"}
{user id :-&gt; 942, age :-&gt; 48, gender :-&gt; "F", occupation :-&gt; "librarian", zip code :-&gt; "78209"}
{user id :-&gt; 943, age :-&gt; 22, gender :-&gt; "M", occupation :-&gt; "student", zip code :-&gt; "77841"}
</pre>

<p>
This lets us view a subset of rows,
</p>

<pre class="example">
λ&gt; mapM_ (print . frameRow ms) [50..55]
{user id :-&gt; 51, age :-&gt; 28, gender :-&gt; "M", occupation :-&gt; "educator", zip code :-&gt; "16509"}
{user id :-&gt; 52, age :-&gt; 18, gender :-&gt; "F", occupation :-&gt; "student", zip code :-&gt; "55105"}
{user id :-&gt; 53, age :-&gt; 26, gender :-&gt; "M", occupation :-&gt; "programmer", zip code :-&gt; "55414"}
{user id :-&gt; 54, age :-&gt; 22, gender :-&gt; "M", occupation :-&gt; "executive", zip code :-&gt; "66315"}
{user id :-&gt; 55, age :-&gt; 37, gender :-&gt; "M", occupation :-&gt; "programmer", zip code :-&gt; "01331"}
{user id :-&gt; 56, age :-&gt; 25, gender :-&gt; "M", occupation :-&gt; "librarian", zip code :-&gt; "46260"}
</pre>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Column Subset</h3>
<div class="outline-text-3" id="text-2-2">
<p>
We can consider a single column.
</p>

<pre class="example">
λ&gt; take 6 $ F.foldMap ((:[]) . view occupation) ms
["technician","other","writer","technician","other","executive"]
</pre>

<p>
Or multiple columns,
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #A6E22E;">miniUser</span> <span style="color: #FD971F;">::</span> <span style="color: #66D9EF;">Users</span> <span style="color: #FD971F;">-&gt;</span> <span style="color: #66D9EF;">Rec</span> [<span style="color: #66D9EF;">Occupation</span>, <span style="color: #66D9EF;">Gender</span>, <span style="color: #66D9EF;">Age</span>]
<span style="color: #A6E22E;">miniUser</span> <span style="color: #FD971F;">=</span> rcast
</pre>
</div>

<pre class="example">
λ&gt; mapM_ print . take 6 . F.toList $ fmap miniUser ms
{occupation :-&gt; "technician", gender :-&gt; "M", age :-&gt; 24}
{occupation :-&gt; "other", gender :-&gt; "F", age :-&gt; 53}
{occupation :-&gt; "writer", gender :-&gt; "M", age :-&gt; 23}
{occupation :-&gt; "technician", gender :-&gt; "M", age :-&gt; 24}
{occupation :-&gt; "other", gender :-&gt; "F", age :-&gt; 33}
{occupation :-&gt; "executive", gender :-&gt; "M", age :-&gt; 42}
</pre>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Query / Conditional Subset</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Filtering our frame is rather nicely done using the
<a href="http://hackage.haskell.org/package/pipes">pipes</a> package. Here
we pick out the users whose occupation is "writer".
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #A6E22E;">writers</span> <span style="color: #FD971F;">::</span> (<span style="color: #66D9EF;">Occupation</span> <span style="color: #FD971F;">&#8712;</span> rs, <span style="color: #66D9EF;">Monad</span> m) <span style="color: #FD971F;">=&gt;</span> <span style="color: #66D9EF;">Pipe</span> (<span style="color: #66D9EF;">Rec</span> rs) (<span style="color: #66D9EF;">Rec</span> rs) m r
<span style="color: #A6E22E;">writers</span> <span style="color: #FD971F;">=</span> <span style="color: #F8F8F2; background-color: #272822;">P.filter</span> ((<span style="color: #FD971F;">==</span> <span style="color: #E6DB74;">"writer"</span>) <span style="color: #FD971F;">.</span> view occupation)
</pre>
</div>

<pre class="example">
λ&gt; runEffect $ movieStream &gt;-&gt; writers &gt;-&gt; P.take 6 &gt;-&gt; P.print
{user id :-&gt; 3, age :-&gt; 23, gender :-&gt; "M", occupation :-&gt; "writer", zip code :-&gt; "32067"}
{user id :-&gt; 21, age :-&gt; 26, gender :-&gt; "M", occupation :-&gt; "writer", zip code :-&gt; "30068"}
{user id :-&gt; 22, age :-&gt; 25, gender :-&gt; "M", occupation :-&gt; "writer", zip code :-&gt; "40206"}
{user id :-&gt; 28, age :-&gt; 32, gender :-&gt; "M", occupation :-&gt; "writer", zip code :-&gt; "55369"}
{user id :-&gt; 50, age :-&gt; 21, gender :-&gt; "M", occupation :-&gt; "writer", zip code :-&gt; "52245"}
{user id :-&gt; 122, age :-&gt; 32, gender :-&gt; "F", occupation :-&gt; "writer", zip code :-&gt; "22206"}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Better Types</h2>
<div class="outline-text-2" id="text-3">
<p>
A common disappointment of parsing general data sets is the
reliance on text for data representation even <i>after</i> parsing. If
you find that the default <code>Columns</code> spectrum of potential column
types that <code>Frames</code> uses doesn't capture desired structure, you can
go ahead and define your own universe of column types! The <code>Users</code>
row types we've been playing with here is rather boring: it only
uses <code>Int</code> and <code>Text</code> column types. But <code>Text</code> is far too vague a
type for a column like <code>gender</code>.
</p>

<pre class="example">
λ&gt; L.purely P.fold L.nub (movieStream &gt;-&gt; P.map (view gender))
["M", "F"]
</pre>

<p>
Aha! The <code>gender</code> column is pretty simple, so let's go ahead and
define our own universe of column types.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #F92672;">data</span> <span style="color: #66D9EF;">GenderT</span> <span style="color: #FD971F;">=</span> <span style="color: #66D9EF;">Male</span> <span style="color: #FD971F;">|</span> <span style="color: #66D9EF;">Female</span> <span style="color: #F92672;">deriving</span> (<span style="color: #66D9EF;">Eq</span>,<span style="color: #66D9EF;">Show</span>,<span style="color: #66D9EF;">Typeable</span>)

<span style="color: #F92672;">type</span> <span style="color: #F92672;">instance</span> <span style="color: #66D9EF;">VectorFor</span> <span style="color: #66D9EF;">GenderT</span> <span style="color: #FD971F;">=</span> <span style="color: #66D9EF;">V.Vector</span>

<span style="color: #F92672;">instance</span> <span style="color: #66D9EF;">Readable</span> <span style="color: #66D9EF;">GenderT</span> <span style="color: #F92672;">where</span>
  fromText <span style="color: #E6DB74;">"M"</span> <span style="color: #FD971F;">=</span> return <span style="color: #66D9EF;">Male</span>
  fromText <span style="color: #E6DB74;">"F"</span> <span style="color: #FD971F;">=</span> return <span style="color: #66D9EF;">Female</span>
  fromText <span style="color: #F92672;">_</span> <span style="color: #FD971F;">=</span> mzero

<span style="color: #F92672;">type</span> <span style="color: #66D9EF;">MyColumns</span> <span style="color: #FD971F;">=</span> <span style="color: #66D9EF;">GenderT</span> '<span style="color: #66D9EF;">:</span> <span style="color: #66D9EF;">CommonColumns</span>
</pre>
</div>

<p>
The full code for the custom type may be found in an <a href="#sec-4-1">appendix</a>. Note
that it must be defined in a separate module to satisfy GHC's stage
restrictions related to Template Haskell.
</p>

<p>
We name this record type <code>U2</code>, and give all the generated column types
and lenses a prefix, "u2", so they don't conflict with the definitions
we generated earlier.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #A6E22E;">tableTypes'</span> rowGen { rowTypeName <span style="color: #FD971F;">=</span> <span style="color: #E6DB74;">"U2"</span>
                   , columnNames <span style="color: #FD971F;">=</span> [ <span style="color: #E6DB74;">"user id"</span>, <span style="color: #E6DB74;">"age"</span>, <span style="color: #E6DB74;">"gender"</span>
                                   , <span style="color: #E6DB74;">"occupation"</span>, <span style="color: #E6DB74;">"zip code"</span> ]
                   , separator <span style="color: #FD971F;">=</span> <span style="color: #E6DB74;">"|"</span>
                   , tablePrefix <span style="color: #FD971F;">=</span> <span style="color: #E6DB74;">"u2"</span>
                   , columnUniverse <span style="color: #FD971F;">=</span> <span style="color: #FD971F;">$</span>(colQ ''MyColumns) }
            <span style="color: #E6DB74;">"data/ml-100k/u.user"</span>

<span style="color: #A6E22E;">movieStream2</span> <span style="color: #FD971F;">::</span> <span style="color: #66D9EF;">Producer</span> <span style="color: #66D9EF;">U2</span> <span style="color: #66D9EF;">IO</span> <span style="color: #66D9EF;">()</span>
<span style="color: #A6E22E;">movieStream2</span> <span style="color: #FD971F;">=</span> readTableOpt u2Parser <span style="color: #E6DB74;">"data/ml-100k/u.user"</span>
</pre>
</div>

<p>
This new record type, <code>U2</code>, has a more interesting <code>gender</code>
column.
</p>

<pre class="example">
λ&gt; :i U2
type U2 =
  Rec
    '["user id" :-&gt; Int, "age" :-&gt; Int, "gender" :-&gt; GenderT,
      "occupation" :-&gt; Text, "zip code" :-&gt; Text]
</pre>

<p>
Let's take the occupations of the first 10 male users:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #A6E22E;">maleOccupations</span> <span style="color: #FD971F;">::</span> (<span style="color: #66D9EF;">U2gender</span> <span style="color: #FD971F;">&#8712;</span> rs, <span style="color: #66D9EF;">U2occupation</span> <span style="color: #FD971F;">&#8712;</span> rs, <span style="color: #66D9EF;">Monad</span> m)
                <span style="color: #FD971F;">=&gt;</span> <span style="color: #66D9EF;">Pipe</span> (<span style="color: #66D9EF;">Rec</span> rs) <span style="color: #66D9EF;">Text</span> m r
<span style="color: #A6E22E;">maleOccupations</span> <span style="color: #FD971F;">=</span> <span style="color: #F8F8F2; background-color: #272822;">P.filter</span> ((<span style="color: #FD971F;">==</span> <span style="color: #66D9EF;">Male</span>) <span style="color: #FD971F;">.</span> view u2gender)
                  <span style="color: #FD971F;">&gt;-&gt;</span> <span style="color: #F8F8F2; background-color: #272822;">P.map</span> (view u2occupation)
</pre>
</div>

<pre class="example">
λ&gt; runEffect $ movieStream2 &gt;-&gt; maleOccupations &gt;-&gt; P.take 10 &gt;-&gt; P.print
"technician"
"writer"
"technician"
"executive"
"administrator"
"administrator"
"student"
"lawyer"
"educator"
"scientist"
</pre>

<p>
So there we go! We've done both row and column subset queries with a
strongly typed query (namely, <code>(== Male)</code>). Another situation in
which one might want to define a custom universe of column types is
when dealing with dates. This would let you both reject rows with
badly formatted dates, for example, and efficiently query the data set
with richly-typed queries.
</p>

<p>
Even better, did you notice the types of <code>writers</code> and
<code>maleOccupations</code>? They are polymorphic over the full row type!
That's what the <code>(Occupation ∈ rs)</code> constraint signifies: such a
function will work for record types with any set of fields, <code>rs</code>, so
long as <code>Occupation</code> is an element of that set. This means that if
your schema changes, or you switch to a related but different data
set, <b>these functions can still be used without even touching the
code</b>. Just recompile against the new data set, and you're good to go.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Appendix</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> User Types</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Here are the definitions needed to define the <code>MyColumns</code> type with its
more descriptive <code>GenderT</code> type. We have to define these things in a
separate module from our main work due to GHC's stage restrictions
regarding Template Haskell. Specifically, <code>GenderT</code> and its instances
are used at compile time to infer the record type needed to represent
the data file. Notice the extension point here is not too rough: you
prepend new, more refined, type compatibility checks to the head of
<code>CommonColumns</code>, or you can build up your own list of expected types.
</p>

<p>
This may not be something you'd want to do for every data
set. However, the <i>ability</i> to refine the structure of parsed data
is in keeping with the overall goal of <code>Frames</code>: it's easy to take
off, and the sky's the limit.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #75715E; font-style: italic;">{-# LANGUAGE DataKinds, DeriveDataTypeable, GeneralizedNewtypeDeriving,</span>
<span style="color: #75715E; font-style: italic;">             MultiParamTypeClasses, OverloadedStrings, TemplateHaskell,</span>
<span style="color: #75715E; font-style: italic;">             TypeFamilies, TypeOperators #-}</span>
<span style="color: #F92672;">module</span> <span style="color: #66D9EF;">TutorialUsers</span> <span style="color: #F92672;">where</span>
<span style="color: #F92672;">import</span> <span style="color: #66D9EF;">Control.Monad</span> (mzero)
<span style="color: #F92672;">import</span> <span style="color: #66D9EF;">Data.Readable</span> (<span style="color: #66D9EF;">Readable</span>(fromText))
<span style="color: #F92672;">import</span> <span style="color: #66D9EF;">Data.Typeable</span>
<span style="color: #F92672;">import</span> <span style="color: #F92672;">qualified</span> <span style="color: #66D9EF;">Data.Vector</span> <span style="color: #F92672;">as</span> <span style="color: #66D9EF;">V</span>
<span style="color: #F92672;">import</span> <span style="color: #66D9EF;">Frames.InCore</span> (<span style="color: #66D9EF;">VectorFor</span>)
<span style="color: #F92672;">import</span> <span style="color: #66D9EF;">Frames</span>

<span style="color: #F92672;">data</span> <span style="color: #66D9EF;">GenderT</span> <span style="color: #FD971F;">=</span> <span style="color: #66D9EF;">Male</span> <span style="color: #FD971F;">|</span> <span style="color: #66D9EF;">Female</span> <span style="color: #F92672;">deriving</span> (<span style="color: #66D9EF;">Enum</span>,<span style="color: #66D9EF;">Eq</span>,<span style="color: #66D9EF;">Ord</span>,<span style="color: #66D9EF;">Show</span>,<span style="color: #66D9EF;">Typeable</span>)

<span style="color: #75715E;">-- </span><span style="color: #75715E; font-style: italic;">See @demo/TutorialUsers.hs@ in the repository for an example of how</span>
<span style="color: #75715E;">-- </span><span style="color: #75715E; font-style: italic;">to define a packed representation for a custom column type. It uses</span>
<span style="color: #75715E;">-- </span><span style="color: #75715E; font-style: italic;">the usual "Data.Vector.Generic" machinery.</span>
<span style="color: #F92672;">type</span> <span style="color: #F92672;">instance</span> <span style="color: #66D9EF;">VectorFor</span> <span style="color: #66D9EF;">GenderT</span> <span style="color: #FD971F;">=</span> <span style="color: #66D9EF;">V.Vector</span>

<span style="color: #F92672;">instance</span> <span style="color: #66D9EF;">Readable</span> <span style="color: #66D9EF;">GenderT</span> <span style="color: #F92672;">where</span>
  fromText <span style="color: #E6DB74;">"M"</span> <span style="color: #FD971F;">=</span> return <span style="color: #66D9EF;">Male</span>
  fromText <span style="color: #E6DB74;">"F"</span> <span style="color: #FD971F;">=</span> return <span style="color: #66D9EF;">Female</span>
  fromText <span style="color: #F92672;">_</span> <span style="color: #FD971F;">=</span> mzero

<span style="color: #F92672;">type</span> <span style="color: #66D9EF;">MyColumns</span> <span style="color: #FD971F;">=</span> <span style="color: #66D9EF;">GenderT</span> '<span style="color: #66D9EF;">:</span> <span style="color: #66D9EF;">CommonColumns</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Splice Dump</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The Template Haskell splices we use produce quite a lot of
code. The raw dumps of these splices can be hard to read, but I have
included some elisp code for cleaning up that output in the design
notes for <code>Frames</code>. Here is what we get from the <code>tableTypesOpt</code>
splice shown above.
</p>

<p>
The overall structure is this:
</p>

<ul class="org-ul">
<li>A <code>Rec</code> type called <code>Users</code> with all necessary columns
</li>
<li>A <code>usersParser</code> value that overrides parsing defaults
</li>
<li>A type synonym for each column that pairs the column name with its
type
</li>
<li>A lens to work with each column on any given row
</li>
</ul>

<p>
Remember that for CSV files that include a header, the splice you
write in your code need not include the column names or separator
character.
</p>

<pre class="example">
    tableTypes'
      (rowGen
         {rowTypeName = "Users",
          columnNames = ["user id", "age", "gender", "occupation",
                         "zip code"],
          separator = "|"})
      "data/ml-100k/u.user"
  ======&gt;
    /Users/acowley/Documents/Projects/Frames/demo/Tutorial.hs:(52,1)-(56,34)
    type Users =
        Rec ["user id" :-&gt; Int, "age" :-&gt; Int, "gender" :-&gt; Text, "occupation" :-&gt; Text, "zip code" :-&gt; Text]

    usersParser :: ParserOptions
    usersParser
      = ParserOptions
          (Just
             (map
                T.pack
                ["user id", "age", "gender", "occupation", "zip code"]))
          (T.pack "|")

    type UserId = "user id" :-&gt; Int

    userId ::
      forall f_ad5z rs_ad5A. (Functor f_ad5z,
                              RElem UserId rs_ad5A (RIndex UserId rs_ad5A)) =&gt;
      (Int -&gt; f_ad5z Int) -&gt; Rec rs_ad5A -&gt; f_ad5z (Rec rs_ad5A)
    userId = rlens (Proxy :: Proxy UserId)

    userId' ::
      forall g_ad5B f_ad5C rs_ad5D. (Functor f_ad5C,
                                     Functor g_ad5B,
                                     RElem UserId rs_ad5D (RIndex UserId rs_ad5D)) =&gt;
      (g_ad5B Int -&gt; f_ad5C (g_ad5B Int))
      -&gt; RecF g_ad5B rs_ad5D -&gt; f_ad5C (RecF g_ad5B rs_ad5D)
    userId' = rlens' (Proxy :: Proxy UserId)

    type Age = "age" :-&gt; Int

    age ::
      forall f_ad5E rs_ad5F. (Functor f_ad5E,
                              RElem Age rs_ad5F (RIndex Age rs_ad5F)) =&gt;
      (Int -&gt; f_ad5E Int) -&gt; Rec rs_ad5F -&gt; f_ad5E (Rec rs_ad5F)
    age = rlens (Proxy :: Proxy Age)

    age' ::
      forall g_ad5G f_ad5H rs_ad5I. (Functor f_ad5H,
                                     Functor g_ad5G,
                                     RElem Age rs_ad5I (RIndex Age rs_ad5I)) =&gt;
      (g_ad5G Int -&gt; f_ad5H (g_ad5G Int))
      -&gt; RecF g_ad5G rs_ad5I -&gt; f_ad5H (RecF g_ad5G rs_ad5I)
    age' = rlens' (Proxy :: Proxy Age)

    type Gender = "gender" :-&gt; Text

    gender ::
      forall f_ad5J rs_ad5K. (Functor f_ad5J,
                              RElem Gender rs_ad5K (RIndex Gender rs_ad5K)) =&gt;
      (Text -&gt; f_ad5J Text) -&gt; Rec rs_ad5K -&gt; f_ad5J (Rec rs_ad5K)
    gender = rlens (Proxy :: Proxy Gender)

    gender' ::
      forall g_ad5L f_ad5M rs_ad5N. (Functor f_ad5M,
                                     Functor g_ad5L,
                                     RElem Gender rs_ad5N (RIndex Gender rs_ad5N)) =&gt;
      (g_ad5L Text -&gt; f_ad5M (g_ad5L Text))
      -&gt; RecF g_ad5L rs_ad5N -&gt; f_ad5M (RecF g_ad5L rs_ad5N)
    gender' = rlens' (Proxy :: Proxy Gender)

    type Occupation = "occupation" :-&gt; Text

    occupation ::
      forall f_ad5O rs_ad5P. (Functor f_ad5O,
                              RElem Occupation rs_ad5P (RIndex Occupation rs_ad5P)) =&gt;
      (Text -&gt; f_ad5O Text) -&gt; Rec rs_ad5P -&gt; f_ad5O (Rec rs_ad5P)
    occupation
      = rlens (Proxy :: Proxy Occupation)

    occupation' ::
      forall g_ad5Q f_ad5R rs_ad5S. (Functor f_ad5R,
                                     Functor g_ad5Q,
                                     RElem Occupation rs_ad5S (RIndex Occupation rs_ad5S)) =&gt;
      (g_ad5Q Text -&gt; f_ad5R (g_ad5Q Text))
      -&gt; RecF g_ad5Q rs_ad5S -&gt; f_ad5R (RecF g_ad5Q rs_ad5S)
    occupation'
      = rlens' (Proxy :: Proxy Occupation)

    type ZipCode = "zip code" :-&gt; Text

    zipCode ::
      forall f_ad5T rs_ad5U. (Functor f_ad5T,
                              RElem ZipCode rs_ad5U (RIndex ZipCode rs_ad5U)) =&gt;
      (Text -&gt; f_ad5T Text) -&gt; Rec rs_ad5U -&gt; f_ad5T (Rec rs_ad5U)
    zipCode = rlens (Proxy :: Proxy ZipCode)

    zipCode' ::
      forall g_ad5V f_ad5W rs_ad5X. (Functor f_ad5W,
                                     Functor g_ad5V,
                                     RElem ZipCode rs_ad5X (RIndex ZipCode rs_ad5X)) =&gt;
      (g_ad5V Text -&gt; f_ad5W (g_ad5V Text))
      -&gt; RecF g_ad5V rs_ad5X -&gt; f_ad5W (RecF g_ad5V rs_ad5X)
    zipCode' = rlens' (Proxy :: Proxy ZipCode)
</pre>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Thanks</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Thanks to Greg Hale for reviewing an early draft of this document.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
